==========
Типы данных:
Изменяемые : List,set,dict
Неизменяемые:Str,typle,int,float,frozenset,bool
==========
Отличия == и is
== сравнивает 2 операнда по значению
is сравнивает по адресам в памяти
==========
Args kwargs
аргументы передаются либо по значению(неизменяемые) либо по ссылке(изменяемые)
*args(typle) - принимает неограниченное получение позиционных элементов
 **kwargs(dict)- при помощи ключевых слов
==========
аннотация типов
Class A:
	some:int (:int подсказка для программиста на вход)
==========
Lamda применение
Ананимная функция для вычисление с невидемым реберном
==========
Тернарный оператор
 if для читаемости
==========
Глубинная и поверхностная копия
s = [1, [2 ],3] (is)
copy.copy - на индесна True на s false
copy.deepcopy на все False
 ==========
Виртуальное окружение
Не засорять глобальный пайтон а создавать окружение со своими библиотеками и не мешают поекты друг-другу
==========
Poetry
Pip - стандартный
Poetry -от разрабов более удобных
==========
Как оценивается сложность алгоритма (Big o notation)
Есть цикл n
если рекурсия -логарифм
цикл в Циле n**2
============================================
Что такое self
self - ссылка на текущий созданый объект созданого класса
Super- доступ к родительским классам(в магических метадах)
==========
методы класс - класс для построение объекта
Class A:
	def a (self):
	      pass
	@classmethod
	def b (cls):
	      pass
	@staticmethod
	def c ():
	      pass
a = A()
	a.a()
A.b()
A.c()
==========
модификаторы доступа
Public ‘'
Privat __
Protected _
==========
Декоратор
==========
Абстрактный класс
Класс у которого нельзя создать объект
в которых пишем абстрактные метод

From abc import ABC, abstractmethod
Class A(ABC)
	@abstractmethod
	def(some):
		pass
Class B(A)
	def some():
		print(‘ok’)
==========
Метакласс - для построения класса
перехватить или изменить поведение класс
__new(cоздает класс),init(инициализация),call(создание объекта класса)__
==========
что такое ООП
строим код в виде объектов которые явлются объектами какого-то класса и выстраивается иерархия наследованная
парадигмы ===
1_Абстракция - в коде используем только те характеристики объекта которые нужны сейчас
2_Наследование- Родительский-дочерний(наследует сва-ва родителя и может использовать свои)
3_Инкопсуляция(сокрытие данных __ _ ,внутренние свойства объекта может меняться только им самим)
4_Полиморфизм-не важно какие типы аргумента приходят в фунцию,главное чтобы мы их могли там обработать и вывести ответ (4+4)(‘4’+’4’)
=====================================
Миксины
небольшие классы с функционалом где мы используем во многих классах
=====================================
Что такое MRO метод резалюшин ордерин
список внутри классов который показывает путь (дочерный-родитель)
=====================================
Итератор (iter,next)
Можно пройтись по элементам
(iter,next) можно разнести по разным классам
=====================================
Генератор - функции где вместо ретерна yeald
от илда к илду получаем объекты
любой генератор является итератором
=====================================
Тестирование - для
Pytest - сторонние разрабочики(широкий функционал)для pep8
Unittest - встроен, по дефолту в джанго,тестирует класс, функции
Mock - объект подменяет объект и возвращает ожидаемый результат
=====================================
ORM - объектно релиационное отображение
cвязывает бд с моделями
=====================================
чем отличается абсолютный импорт от обсалютного
if main=name
===================Практики======================
Kiss(keep it simple, stupid)-делать фонкции ровно то что нужно и не более
Dry(Don't Repeat Yourself)-не повторяться
Yagni(You aren't gonna need it) - Вам это не понадобится
SOLID
S) Single-responsibility principle /Принцип единственной ответственности
 Каждый объект, класс и метод должны отвечать только за что-то одно. и связана с его основной ответственностью ( Класс только добавляет запись а не редактирует+загружает+записывает)

O) Open–closed principle / Принцип открытости-закрытости
Программные объекты должны быть открыты для расширения, но закрыты для модификации. (создать базовые классны-наследоваться отних и так расширить функционал)


L) Liskov substitution principle / Принцип подстановки Лисков(Барбара)
Этот принцип гласит, что объекты старших классов должны быть заменимы объектами подклассов, и приложение при такой замене должно работать так, как ожидается.(если класс прямоугольник не надо там считать площадь квадрата потому что это прямоугольник)

I) Interface segregation principle / Принцип разделения интерфейсов
Объекты не должны зависеть от интерфейсов, которые они не используют (чтобы юзеры не использовали лишние методы)
!!!!!====class Machine:
			def print(self, document):
				raise NotImplementedError
			def fax(self, document):
				raise NotImplementedError
			def scan(self, document):
				raise NotImplementedError. ======!!!!!!!!!!!!

Class Printer:
	@abstractmethod
	def print(self, document):
		pass
Class Scanner:
	@abstractmethod
	def scan(self, document):
		pass

Class MyPtinter(Printer):
	def print(self, document):
		print(document)

Class Photocopire(Scanner,Printer):
	def scan(self, document):
		pass
	def print(self, document):
		pass



D) Dependency inversion principle / Принцип инверсии зависимостей

 Мы должны полагаться на абстракции, а не на конкретные реализации. Компоненты ПО должны иметь низкую связность и высокую согласованность.


=====================================
Патерны проектирования
Параждающие
Поведенческие
Структурные
======БД====
SQL -
Запросы SELECT JOIN
Primery key
Forighn key
индексы - завести поле индекс для удоьсива
Триггеры -события потом по этим события делать действия(обновляешь запись в бд и меняется время)
Транзакция-будут выполнены все оперыции или непройдет ни одна







